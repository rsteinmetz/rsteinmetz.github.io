<div id="inner">
    <div class="slideIntroText">
    </div>
    <div id="tooltip"></div>
    <div>
        <div class="align-center">
            <span id="dateRangeStartText"></span> to <span id="dateRangeEndText"></span>
        </div>
        <input id="stockSlider" class="stockSlider" type="range" min="0" max="30" value="0" class="slider" id="dateRange"/>
    </div>
    <div id="scene4"></div>
    <script>
        function addDays(date, days) {
            var result = date;
            date.setHours(date.getHours() + (24 * days))
            return result;
        }

        var baseDate = new Date("2010-06-30")
        var stockSlider = document.getElementById("stockSlider")
        var startTime = document.getElementById("dateRangeStartText")
        var endTime = document.getElementById("dateRangeEndText")
        $("#dateRangeStartText").text(baseDate.toLocaleDateString("en-US"))
        $("#dateRangeEndText").text(new Date(baseDate.setDate(baseDate.getDate() + 90)).toLocaleDateString("en-US"))

        stockSlider.oninput = function() {
            var currentStart = new Date(startTime.textContent)
            var newStartDate = new Date(addDays(new Date(currentStart), this.value));
            var newEndDate = new Date(addDays(new Date(newStartDate), 90))

            $("#dateRangeStartText").text(newStartDate.toLocaleDateString("en-US"))
            $("#dateRangeEndText").text(newEndDate.toLocaleDateString("en-US"))
            updateChart()
        }

        // initailize screen data
        var margin = {
            top: 30,
            right: 30,
            bottom: 70,
            left: 60
        }
        var width = 1600 - margin.left - margin.right
        var height = 900 - margin.top - margin.bottom 
        var tooltip = d3.select("#tooltip").attr("pointer-events", "none")
        var data = []
        var filteredData = []

        var svg = d3
            .select("#scene4")
            .append("svg")
            .attr("id", "graph")
            .attr("width", "100%")
            .attr("height", height + margin.top + margin.bottom)
            .append("g")
            .attr("transform", "translate(" + margin.left + "," + margin.top + ")");


        function updateChart() {

            var start = $("#dateRangeStartText").text()
            var end = $("#dateRangeEndText").text()
            filteredData = _.filter(data, function(f) { 
                console.log(f.date.toISOString().slice(0,10))
                return f.date.toISOString().slice(0,10) >= new Date(start).toISOString().slice(0,10) && f.date.toISOString().slice(0,10) <= new Date(end).toISOString().slice(0,10) 
                })
            filteredData = _.sortBy(filteredData, 'date')

            var formatDate = d3.utcFormat("%B %-d, %Y")
            var formatValue = d3.format(".2f")
            var parseDate = d3.utcParse("%Y-%m-%d")
            var formatChange = function() {
                const f = d3.format("+.2%");
                return (y0, y1) => f((y1 - y0) / y0);
            }

            // we have dates, need to filter down the dataset to be the

            x = d3.scaleBand()
                .domain(d3.utcDay
                    .range(filteredData[0].date, +filteredData[filteredData.length - 1].date + 1)
                    .filter(d => d.getUTCDay() !== 0 && d.getUTCDay() !== 6))
                .range([margin.left, width - margin.right])
                .padding(0.2)

            xAxis = g => g
                .attr("transform", `translate(0,${height - margin.bottom})`)
                .call(d3.axisBottom(x).tickValues([filteredData[0].date, filteredData[filteredData.length -1].date])
                    .tickValues(d3.utcMonday
                        .every(width > 720 ? 1 : 2)
                        .range(filteredData[0].Date, filteredData[filteredData.length - 1].date))
                    .tickFormat(d3.utcFormat("%-m/%-d"))
                )
                .call(g => g.select(".domain").remove())

            y = d3.scaleLog()
                .domain([d3.min(filteredData, d => d.low), d3.max(filteredData, d => d.high)])
                .rangeRound([height - margin.bottom, margin.top])

            yAxis = g => g
                .attr("transform", `translate(${margin.left},0)`)
                .call(d3.axisLeft(y)
                    .tickFormat(d3.format("$~f"))
                    .tickValues(d3.scaleLinear().domain(y.domain()).ticks()))
                .call(g => g.selectAll(".tick line").clone()
                    .attr("stroke-opacity", 0.2)
                    .attr("x2", width - margin.left - margin.right))
                .call(g => g.select(".domain").remove())

            // add x axis 
            svg.append("g")
                .attr("transform", "translate(0, " + height + ")")
                .call(
                    d3.axisBottom(x)
                    .tickValues(
                        x.domain().filter(function(d,i) { return !(i%25)})
                    )
                    .tickFormat(function(d) {  return new Date(d).toLocaleDateString("en-US"); })
                )
                .selectAll("text")
                .attr("transform", "translate(-10,0)rotate(-45)")
                .style("text-anchor", "end")


            // svg.append("g")
            // .call(xAxis)

            svg.append("g")
            .call(yAxis)

            const g = svg.append("g")
                .attr("stroke-linecap", "round")
                .attr("stroke", "black")
                .selectAll("g")
                .data(filteredData)
                .join("g")
                .attr("transform", d => `translate(${x(d.date)},0)`);

            // // exit the old elemeents
            // d3.selectAll("line")
            // .exit()
            // //.transition(t)
            // // .attr("y", 0)
            // .remove();

            g.append("line")
            .attr("y1", d => y(d.low))
            .attr("y2", d => y(d.high))

            g.append("line")
            .attr("y1", d => y(d.open))
            .attr("y2", d => y(d.close))
            .attr("stroke-width", x.bandwidth)
            .attr("stroke", d => d.open > d.close ? d3.schemeSet1[0]
            : d.close > d.open ? d3.schemeSet1[2]
            : d3.schemeSet1[8])
            .on("mouseover", function(d,i) {
                tooltip
                .style("opacity", 1)
                .style("left", (d3.event.pageX+50)+"px")
                .style("top", (d3.event.pageY)+"px")
                .html(`Date: ${d.date.toLocaleDateString("en-US")}<br/>
                High: $ ${d.high}<br/>
                Open: $ ${d.open}<br/>
                Close: $ ${d.close}<br/>
                Low: $ ${d.close}`)
            })
            .on("mouseout", function(d,i) {
                tooltip
                .style("opacity", 0)
            })


            svg.append("text")      // text label for the x axis
                .attr("x", 700 )
                .attr("y", 870 )
                .style("text-anchor", "middle")
                .text("Date");

                svg.append("text")
                        .attr("transform", "rotate(-90)")
                        .attr("y", 0 - margin.left)
                        .attr("x",0 - (height / 2))
                        .attr("dy", "1em")
                        .style("text-anchor", "middle")
                        .text("Stock Price");


        }

        // grab dataset
        d3
            .csv("https://raw.githubusercontent.com/rsteinmetz/rsteinmetz.github.io/master/cs-498/data/tesla-stock.csv")
            .then((d) => {
                var parseDate = d3.utcParse("%Y-%m-%d");
                var a = [];
                for (var i = 0; i < d.length; i++) {
                    a.push({
                        date: parseDate(d[i].date),
                        high: +d[i].high,
                        low: +d[i].low,
                        open: +d[i].open,
                        close: +d[i].close
                    })
                }
                data = _.sortBy(a, 'date');
                updateChart()
            })
    </script>
</div>